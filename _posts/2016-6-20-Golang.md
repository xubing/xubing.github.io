---
layout:  post
title:  Golang基础
tags: Golang
description: Golang的基础入门
comments: true
---

### GOlang
	被誉为替代Java的新一代网络语言，的确很好。暂时先写一个简单的流程，有些可能先列出提纲。很早就学习了，学习笔记在evernote上写了不少，感觉还是整理放在github上，和大家一起学习。

### 常用传送门

- [官方文档](https://go-zh.org/doc/)
- 推荐书&参考文档
	- 官方在线教程。https://go-zh.org
	- The Go programming language
	- Effective Go
	- 本地api查看， 命令行运行 godoc -http=:8080 然后浏览器打开

### IDE
- Intellij Idea 安装Go的插件
- eclipse 安装插件https://github.com/GoClipse/releases/raw/master/
- http://www.golangtc.com/download/liteide

### 安装
- 下载
- 设置环境路径

### 代码风格

- { 的位置
- 骆驼命名。
- 直接执行go fmt  *.go进行代码的格式化。
- 目录结构

### 语法
- 在 Go 中，首字母大写的名称是被导出的,小写隐藏。
- var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。var i int
- 变量定义可以包含初始值，每个变量对应一个。var i, j int = 1, 2
### 类型

#### 整形
 
 有int8、int16、int32和int64四种截然不同大小的有符号整形数类型，分别对应8、16、32、64bit大小的有符号整形数，与此对应的是uint8、uint16、uint32和uint64四种无符号整形数类型。因此你的运算可能会溢出。

{% highlight golang linenos %}
	//overflow
	var u8 uint8 = 255
	fmt.Println(u8,u8+1,u8+2)	
	var u  = 255
	fmt.Println(u,u+1,u+2)
{% endhighlight golang %}

- 位操作

Go语言还提供了以下的bit位操作运算符.
位操作运算符&^用于按位置零（AND NOT）：表达式z = x &^ y结果z的bit位为0，如果对应y中bit位为1的话，否则对应的bit位等于x相应的bit位的值。

{% highlight golang linenos %} 
	//bit operator
	var x uint8 = 1<<1 | 1<<5
	var y uint8 = 1<<1 | 1<<2
	fmt.Printf("%08b\n", x)
	fmt.Printf("%08b\n", y)
	fmt.Println("")
	fmt.Printf("%08b\n", x&y) //位运算 AND
	fmt.Printf("%08b\n", x|y) //位运算 OR
	fmt.Printf("%08b\n", x^y) //位运算 XOR
	fmt.Printf("%08b\n", x&^y) // 位清空 (AND NOT)
{% endhighlight golang %}

- 8 16 10进制的打印
可以用%d、%o或%x参数控制输出的进制格式
字符使用%c参数打印，或者是用%q参数打印带单引号的字符.
{% highlight golang linenos %} 
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)

//%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。
{% endhighlight golang %}
#### 浮点数
#### 复数

Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：

####  字符串

一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

内置的len函数可以返回一个字符串中的字节数目。
一个原生的字符串面值形式 `xxxx`,使用反引号代替双引号。
标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。

string  字符串的内容可以用类似于数组下标的方式获取,但与数组不同,字符串的内容不能在初始化后被修改。
    - 支持中文。
    
    {% highlight golang linenos %}
    str := "hello中国"
    fmt.Println("len:",len(str))
    for i,ch := range str {
        fmt.Println(i,string(ch))
     }
     {% endhighlight golang %}
     
####  常量

每种常量的潜在类型都是基础类型：boolean、string或数字。它们的值是在编译期就确定的。

- 常量的定义与变量类似，只不过使用 const 关键字。
- 常量可以是字符、字符串、布尔或者类型的值。
常量不能使用 := 语法定义。
- 定义常量组的时候，如果不提供初始值，则表示使用上行的表达式。

{% highlight golang linenos %}
const
(
	a = 1
	b
	c
)

const
(
	d, e = 1,2
	f, g
)

func main() {
 fmt.Println(a, b, c)
 fmt.Println(d,e,f,g)
}

//输出 1 1 1 .
//输出 1 2 1 2
 {% endhighlight golang %}
####  iota 常量生成器

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。

- 预定义常量
    - true  false  itoa .itoa 下一个const出现之前,每出现一次iota,其所代表的数字会自动增1。她和出现的位置有关。
    
{% highlight golang linenos %}
const
(
	aa = 2
	bb = iota
	cc = iota
	dd = 0
	ee = iota
)

const
(
	cccc = 100
	bbbb = iota
)

func main() {

	fmt.Println(a, b, c)
	fmt.Println(d,e,f,g)
	fmt.Println(aa,bb,cc,dd,ee,bbbb)
}

//2 1 2 0 4 1


//test2
const(
	B float64 = 1 <<(iota*10)
	KB
	MB
)
func main() {I
	fmt.Println(B,KB,MB) //1 1024 1.048576e+06
}


{% endhighlight golang %}


- 与 C 不同的是 Go 的在不同类型之间的项目赋值时需要显式转换。
##### 类型推导
    
    - 在定义一个变量却并不显式指定其类型时（使用 := 语法或者 var = 表达式语法）， 变量的类型由（等号）右侧的值推导得出。
- 类型的转换。必须显式声明。Type(vale)  

```
 a := int(b)
```
###  数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组
- 类型 [n]T 是一个有 n 个类型为 T 的值的数组。  var a[10] int
- 在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算
- 数组的长度是其类型的一部分，因此数组不能改变大小。
- 数组可以进行 == !=的比较
- 指定一个索引和对应值列表的方式初始化
{% highlight golang linenos %}
type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
r := [...]int{99: -1}
{% endhighlight golang %}


{% highlight golang linenos %}
//对最后一个数组设置值，其他默认值。
a:=[4]int{3:10}
fmt.Println(a) //[0 0 0 10]
b:=[...]int{3:10,6:5}
fmt.Println(b) //[0 0 0 10 0 0 5]
	
//new一个数组
p := new ([10]int)
p[2] =2
fmt.Println(p) //&[0 0 2 0 0 0 0 0 0 0]
{% endhighlight golang %}

###  Sice

Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。
 
- 一个 slice 会指向一个序列的值，并且包含了长度信息。 s := []int{2, 3, 5, 7, 11, 13}
- slice 可以重新切片，创建一个新的 slice 值指向相同的数组。 s[1:4]
- slice 由函数 make 创建。这会分配一个全是零值的数组并且返回一个 slice 指向这个数组：
- a := make([]int, 5)  // len(a)=5
- slice 的零值是 nil 。一个 nil 的 slice 的长度和容量是 0。var z []int
- 向 slice 添加元素是一种常见的操作
- append(a, 2, 3, 4) 返回一个新的数组。

###  Map
###  Struct

- 一个结构体（ struct ）就是一个字段的集合。
- 结构体字段使用点号来访问。
- 结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。

{% highlight golang linenos %}	   
type Vertex struct {
     X, Y int
     ｝
v2 = Vertex{X: 1}  // Y:0 被省略   //{1 0 }
{% endhighlight golang  %}	        

- 组合，匿名组合
    - 可见性。
    - 可以访问的以大写字母开头。
    - 可见性是包一级的，而不是类型一级的。
    
###  JSON

- Go语言的大多数数据类型都可以 化为有 的JSON文本
  - 如果转化前的数据结构中出现  ,那么将会 转化所指向的值,如果指向的是指针值, 那么null将作为结果
  - encode
  {% highlight golang linenos %}	   

type DD struct {
	Age int
	Name string
	}
type Book struct  {
Title string
Author []string
Publisher string
IsPublisher bool
Price float32
More *DD
}
func main() {
    d := DD{20,"DD"}
    gobook := Book{"Go lang",
       []string{"111","222"},
       "Publ1",
       true,
       32.2,&d}
    b, err := json.Marshal(gobook)

    if err != nil {
       fmt.Println("Parse error")
    }
   fmt.Println(string(b))
}

{% endhighlight golang  %}     

-decode
{% highlight golang linenos %}
 
 json.Unmarshal( )
//解码未知的Json结构。返回的是一个map[string]interface{}的结构
//解析未知结构的Json
book2 := []byte(`{"Title":"Go lang","Author":["333","222"],"Publisher":"Publ1"}`)
 var b2 interface{}
 if err = json.Unmarshal(book2,&b2);err ==nil{
    fmt.Println("unkonwn:",b2)
 }else {
    fmt.Println("xxxx",err.Error())
 }
{% endhighlight golang %}

   
###  函数
- 小写字母开头的函数只在本包内可见,大写字母开头的函数才 能被其他包使用。
- 不定参数 func myFunc(args … int)
- 任意类型的不定参数 func Printf(format string,args … interface{}){}
- 当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。
	{% highlight golang linenos %}
     func add(x, y int) int {
        return x + y
     }    
	{% endhighlight golang %}
    
- 函数可以返回任意数量的返回值。

	{% highlight golang linenos %}
     func swap(x, y string) (string, string) {
         return y, x
     }
     {% endhighlight golang %}

- 在函数中， **:=** 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， **:=** 结构不能使用在函数外。

### 一些提示	     
- Name
    - Package Name
    - The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. (Don't use the import . notation, which can simplify tests that must run outside the package they are testing, but should otherwise be avoided.)

- Data
    - new

        - unlike its namesakes in some other languages it does not initialize the memory, it only zeros it.
        - That is, new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T.
    - make
        - The built-in function make(T, args) serves a purpose different from new(T). It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T).
    - Remember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly.
    - Map

        - The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays.
        - Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.
        - map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作.
        -
_ = &ages["bob"] // compile error: cannot take address of map element


I
        - 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。
	
{% highlight golang linenos %}	
var v,ok = m[20]
fmt.Println(ok,v)
m[20]++   //危险。因为m[20]原来可以不存在，返回的可能是默认值，现在进行＋＋会进行了赋值
v,ok = m[20]
fmt.Println(ok,v)
{% endhighlight golang %}

        
### 控制语句

- Switch 没有条件的 switch 同 switch true 一样。没有break，满足条件就执行对应的块。
- 这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。
- defer 语句会延迟函数的执行直到上层函数返回。
延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。
- defer 延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用
    
### 指针

- 类型 *T 是指向类型 T 的值的指针。其零值是 nil 。
- & 符号会生成一个指向其作用对象的指针。

- map
    - map 在使用之前必须用 make 而不是 new 来创建；值为 nil 的 map 是空的，并且不能赋值。
- 函数的闭包
    - Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。
- 方法
    - Go没有类。
    - 仍然可以在结构体类型上定义方法。方法接收者 出现在 func 关键字和方法名之间的参数中。
{% highlight golang linenos %}
 type Vertex struct {
     X, Y float64
 }
 func (v *Vertex) Abs() float64 {
     return math.Sqrt(v.X*v.X + v.Y*v.Y)
 }
{% endhighlight golang %} 

- interface

    - 接口类型是由一组方法定义的集合。
    - 接口类型的值可以存放实现这些方法的任何值。
    - 接口类型可以组合。
    - Any 类型。interface{}可以指向任意对象的Any类型。
    - type assertion

        - value.(typename)
        - the result is a new value with the static type typeName
    - unused import and variables

- gorountine
    - goroutine 是由 Go 运行时环境管理的轻量级线程。
- channel
    - 声明形式：   var chanName chan ElementType.   比如    var ch chan int        var m map[string] char bool
    - channel 是有类型的管道，可以用 channel 操作符 <- 对其发送或者接收值。 写入数据  ch <- value    读取数据   value :<- ch
    - select
        - 每个case语句中，必须是一个IO操作。
        - 只要一个case已经完成，程序就会继续往下执行，而不会考虑其他的case的情况。
    - 单向chanel
        - var ch2 cha<- int //只能写入int
        - 初始化  ch4 := make(chan int)    ch5 := <-chan int(chr)
    - 关闭 close()测试是否关闭 x,ok := <- ch
    - 多核并行化
    - 全局唯一性操作  sync.Once

工程管理

- 跨平台开发
- 单元测试
    - _test.go结尾
    - 功能测试&性能测试
        - Testxx (t *testing.T)
        - Benchmarkxxx(t *testing.T)

语言交互

- 调用C
    - import 需要紧跟头文件注释。

部署&交叉编译

- 主要设置 GOOS=linux GOARCH=amd64
- GOOS=linux GOARCH=amd64 revel build github.com/revel/samples/chat ~/Desktop/chat

- 常用的系统及架构
{% highlight bash linenos %} 
$GOOS      $GOARCH
darwin      386
darwin      amd64
freebsd      386
freebsd      amd64
linux      386
linux      amd64
linux      arm      incomplete
windows      386      incomplete
{% endhighlight bash %}     